######
##  Python script to read two FITS files with ra,dec coordinates , in columns names RAJ2000 , DEJ2000
## and match the two lists using astropy.coordinates.SkyCoord
##  Script assembled by Reza Ansari from pieces generated by Gemini - April 2025
# Some minor changes in this version, made by Emile Dosso - April 2025
######

from astropy.io import fits
from astropy.coordinates import SkyCoord
from astropy import units as u
from astropy.cosmology import Planck13

import numpy as np

def match_celestial_objects_list_deg(list1_coords, list2_coords, tolerance_arcsec):
    """
    Matches celestial objects from list1 to all objects in list2 within a tolerance.

    Args:
        list1_coords (list of tuples): List of (ra, dec) tuples for the first list
                                        in decimal degrees.
        list2_coords (list of tuples): List of (ra, dec) tuples for the second list
                                        in decimal degrees.
        tolerance_arcsec (float): The maximum angular separation (in arcseconds)
                                 for a match.

    Returns:
        list of tuples: A list where each tuple contains the indices of the
                        matched objects from list1 and list2, respectively.
                        Returns an empty list if no matches are found.
                        → modif : An object in list1 can match multiple objects in list2.
    """
    if not list1_coords or not list2_coords:
        return []

    coords1 = SkyCoord([ra * u.deg for ra, dec in list1_coords],
                       [dec * u.deg for ra, dec in list1_coords])
    coords2 = SkyCoord([ra * u.deg for ra, dec in list2_coords],
                       [dec * u.deg for ra, dec in list2_coords])

    tolerance_angle = tolerance_arcsec * u.arcsec

    # Use search_around_sky to find all pairs within the tolerance
    idx1, idx2, d2d, d3d = coords2.search_around_sky(coords1, tolerance_angle) # search_around_sky' instead of 'match_to_catalog_sky' will find any
                                                                               # objects within the "tolerance zone" → how to add the tolerance in redshift ?

    # The result idx1, idx2 are the indices of the matched pairs
    matches = list(zip(idx1, idx2))

    return matches

# Simple test of match_celestial_objects_list_deg 
def test_celest_match_list_deg():
    # Example usage:
    list1 = [
        (10.68458, 41.26917),  # M31 - Andromeda Galaxy
        (83.63308, 22.01450),   # M82 - Cigar Galaxy
        (184.6, -64.8)        # Example object
    ]

    list2 = [
        (10.684, 41.27),
        (83.63, 22.01),
        (150.0, 30.0),
        (184.5, -64.75)
    ]

    print("------    test_celest_match_list_deg() ----------");
    
    tolerance = 600.0  # Match within 10 arcmin = 600 arcsec
    
    matched_objects = match_celestial_objects_list_deg(list1, list2, tolerance)

    if matched_objects:
        print(f"Found {len(matched_objects)} matches within {tolerance} arcseconds:")
        for index1, index2 in matched_objects:
            print(f"  List1[{index1}]: {list1[index1]} <-> List2[{index2}]: {list2[index2]}")
    else:
        print(f"No matches found within {tolerance} arcseconds.")

    print("-----------  END of test_celest_match_list_deg() --------------");
    return 
    
        
def match_celestial_objects(coords1, coords2, tolerance_arcsec):
    """
    Matches two lists of celestial objects based on their coordinates.

    Args:
        coords1 : SkyCoord object for the first or main list 
        coords2 : SkyCoord for the second list
        tolerance_arcsec (float): The maximum angular separation (in arcseconds)
                                 for a match.

    Returns:
        list of tuples: A list where each tuple contains the indices of the
                        matched objects from list1 and list2, respectively.
                        Returns an empty list if no matches are found.
    """
    if not coords1 or not coords2:
        return []

    idx, d2d, d3d = coords1.match_to_catalog_sky(coords2)

    matches = []
    tolerance_angle = tolerance_arcsec * u.arcsec

    for i in range(len(coords1)):
        if d2d[i] < tolerance_angle:
            matches.append((i, int(idx[i])))

    return matches


def create_skycoord_from_fits(fits_file):
    """
    Reads a FITS file and creates a SkyCoord object from 'RAJ2000' and 'DEJ2000' columns
    assuming they are in degrees.

    Args:
        fits_file (str): Path to the FITS file.

    Returns:
        astropy.coordinates.SkyCoord or None: A SkyCoord object containing the
                                               coordinates, or None if the
                                               required columns are not found.
    """
    try:
        with fits.open(fits_file) as hdul:
            # Assuming the coordinates are in the first data table (HDU index 1)
            # You might need to adjust the HDU index based on your FITS file structure
            if len(hdul) > 1 and hdul[1].data is not None:
                data = hdul[1].data
                if 'RAJ2000' in data.columns.names and 'DEJ2000' in data.columns.names:
                    ra = data['RAJ2000']
                    dec = data['DEJ2000']
                    coords = SkyCoord(ra=ra * u.deg, dec=dec * u.deg)
                    return coords
                else:
                    print(f"Error: Columns 'RAJ2000' or 'DEJ2000' not found in {fits_file}")
                    return None
            else:
                print(f"Error: No data table found in {fits_file}")
                return None
    except FileNotFoundError:
        print(f"Error: FITS file not found at {fits_file}")
        return None
    except Exception as e:
        print(f"An error occurred while reading {fits_file}: {e}")
        return None

    
def do_celest_match_fits(fits_file1, fits_file2, toler_arcsec):
    print("-------- do_celest_match_fits() : fits files:",fits_file1," , ",fits_file2);

    coords1 = create_skycoord_from_fits(fits_file1)
    coords2 = create_skycoord_from_fits(fits_file2)

    if coords1 is not None:
        print(f"SkyCoord object created from {fits_file1} with {len(coords1)} objects.")
        print(coords1)

    if coords2 is not None:
        print(f"SkyCoord object created from {fits_file2} with {len(coords2)} objects.")
        print(coords2)
        
    matched_objects = match_celestial_objects(coords1, coords2, toler_arcsec)
    
    if matched_objects:
        print(f"Found {len(matched_objects)} matches within {tolerance} arcseconds:")
        for index1, index2 in matched_objects:
            print(f"  coords1[{index1}]: {coords1[index1]} <-> coords2[{index2}]: {coords2[index2]}")
    else:
        print(f"No matches found within {toler_arcsec} arcseconds.")

    print("-----------  END of do_celest_match_fits() --------------");
    return matched_objects

    
def test_celest_match_fits():
    # Example usage: Replace with the actual paths to your FITS files
    fits_file1 = "catalog1.fits"
    fits_file2 = "catalog2.fits"

    print("-------- test_celest_match_fits() : fits files:",fits_file1," , ",fits_file2);
    
    # Create dummy FITS files for testing
    from astropy.table import Table
    ra1 = [10.5, 11.2, 12.8]
    dec1 = [45.1, 46.7, 47.3]
    table1 = Table([ra1, dec1], names=['RAJ2000', 'DEJ2000'])
    table1.write(fits_file1, overwrite=True)

    ra2 = [10.51, 11.18, 13.0]
    dec2 = [45.12, 46.65, 47.0]
    table2 = Table([ra2, dec2], names=['RAJ2000', 'DEJ2000'])
    table2.write(fits_file2, overwrite=True)

    coords1 = create_skycoord_from_fits(fits_file1)
    coords2 = create_skycoord_from_fits(fits_file2)

    if coords1 is not None:
        print(f"SkyCoord object created from {fits_file1} with {len(coords1)} objects.")
        print(coords1)

    if coords2 is not None:
        print(f"SkyCoord object created from {fits_file2} with {len(coords2)} objects.")
        print(coords2)

        
    tolerance = 600.0  # Match within 10 arcmin = 600 arcsec

    matched_objects = match_celestial_objects(coords1, coords2, tolerance)

    if matched_objects:
        print(f"Found {len(matched_objects)} matches within {tolerance} arcseconds:")
        for index1, index2 in matched_objects:
            print(f"  coords1[{index1}]: {coords1[index1]} <-> coords2[{index2}]: {coords2[index2]}")
    else:
        print(f"No matches found within {tolerance} arcseconds.")

    print("-----------  END of test_celest_match_fits() --------------");
    return 


def dotests():
    print("======== dotests() ========= ");
    test_celest_match_list_deg()
    test_celest_match_fits()
    
# Use the Planck 2013 cosmology
    print("--- Testing Cosmology , Planck 2013 ")
    cosmo = Planck13

# Calculate the luminosity distance to redshift z = 1
    luminosity_distance = cosmo.luminosity_distance(z=1)
    print(f"Luminosity distance at z=1: {luminosity_distance}")

# Calculate the age of the universe at redshift z = 0 (present day)
    age_at_z0 = cosmo.age(z=0)
    print(f"Age of the universe today: {age_at_z0}")

# Calculate the Hubble parameter at redshift z = 0
    hubble_parameter_z0 = cosmo.H0
    print(f"Hubble parameter today (H0): {hubble_parameter_z0}")

# Calculate the comoving distance to redshift z = 2
    comoving_distance_z2 = cosmo.comoving_distance(z=2)
    print(f"Comoving distance at z=2: {comoving_distance_z2}")
    return 
    
def ckhello():
    print("Hello World!")

# if __name__ == "__main__":
#    main()
#    dotests();
